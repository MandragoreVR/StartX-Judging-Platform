# StartX Judging Platform

Here is the result of the assignment about a StartX common platform for judges.

One can find a video presentation of the app [here](https://www.loom.com/share/a70dca40555f4ba983fdfcfd9f3891a4?sharedAppSource=personal_library).

## Installation
- Clone the repository
- Once in the repository, install Python requirements with `pip install -r backend/requirements.txt` (you might want to create a virtual environment before that)
- Go to the backend directory, and run `python manage.py makemigrations`and `python manage.py migrate``
- Start the Django server with `python manage.py runserver`, it should run on `127.0.0.1:8000` by itself
- Open the file `index.html` in your browser.

## Technical informations
This app is coded in
- React (highly depending on the Mantine library) for the front part
- Django and its framework REST for the back

## Implemented features
### Calendar
I used the package `react-calendar` in order to display an user-friendly and quite esthetic calendar. It enables the user to select the date they want to know about, and it shows a little green circle the days where at least one interview is scheduled.

### Daily schedule
This daily schedule is displayed in the bow under the calendar, and shows all the interviews scheduled in one day with :
- The name of the company
- The time of the meeting
- One button to see the reviews already posted on this interview
- One button to delete the interview

This daily schedule box also offers the possibility to create new interviews, and I added a small shortcut feature right next to it for testing purposes (it creates three manually planned interviews, and it enables to wipe the interviews database).

### Interview details
The large gray box on the right displays all the details a judge needs to know about a particular interview.

The first part of the frame displays the mean scores of the company in each category, which are :
- Passion and commitment
- Team Dynamics
- Ability to Execute
- Idea
These mean scores are the mean of the scores attributed by the judges in each category, and are updated in the back every time someone adds a new review.

The second part of the frame is a list of all the reviews already given and a button to add a new one. This button is only displayed if the interview is already passed, and it toggles the opening of a form in which a judge can enter all the information they want about the different criteria.

I encountered a strange bug while trying to link the front and the back (something about a JSON syntax error about what I could find nothing useful on the Internet), which explains that it is not possible to create reviews from the front. Then, I added some reviews manually in the front code for testing purposes, but I did not have enough time to resolve this bug.

### Real time update
I did not have enough time either to implement a real-time update, but if I could, I would have used a WebSocket delivered by the back to send an update to the front everytime a new interview or a new review is added.

### Synthesis download
I did not have enough time either to implement the download of a synthesis, but if I could, I would have used a [Jinja2 environment](http://eosrei.net/articles/2015/11/latex-templates-python-and-jinja2-generate-pdfs) (I have already used this technology in the past, that is how I thought of it) generated by a Python script in order to generate a LaTeX file that would then be compiled into a PDF. It would then enable the app to generate a custom LaTeX file with grades and comments that would be different for every company.

## Database
The database I chose is in SQLite, mainly because this is one of the easiest database to run (it doesn't require any configuration and Django creates the file by itself, which made me gain some time).

In my database, there are two tables. Ths first one is `Interview` and is composed of :
- `company` : a string containing the name of the interviewed company
- `date` : a string for the date of the interview, in the format `YYYY-MM-DD-HH:MM``
- `pc_global_score` : a floating number containing the mean score for the criteria Passion and Commitment (equals -1 at creation)
- `td_global_score` : a floating number containing the mean score for the criteria Team Dynamics (equals -1 at creation)
- `ex_global_score` : a floating number containing the mean score for the criteria Ability to execute (equals -1 at creation)
- `id_global_score` : a floating number containing the mean score for the criteria Idea (equals -1 at creation)
and an unique `id` added by Django itself.

The second database is `Review` and is composed of :
- `interview_id` : an integer which is a foreign key to `Interview.id`
- `publication_date` : a string of the same format as `Interview.date` to keep track of when was posted each review
- `judge_name` : the name of the judge who posted the review
- `pc_score` : the score attributed for Passion and Commitment
- `pc_debrief` : the comment of the judge for Passion and Commitment
- `td_score` : the score attributed for Team Dynamics
- `td_debrief` : the comment of the judge for Team Dynamics
- `ex_score` : the score attributed for Ability to Execute
- `ex_debrief` : the comment of the judge for Ability to Execute
- `id_score` : the score attributed for Idea
- `id_debrief` : the comment of the judge for Idea
- `overall_debrief` : an overall comment for the interview

## Ideas of features
### Addition of an authentication system
I would add an authentication system by creating a new database `Users`. The user would then create an account, and the back would then grant an expirable token to the user at each reconnection. This token would be stored in a cookie in the user's browser and would be checked by some authentication decorators added above every Django view.

It would then be possible to implement some permissions : only the judges would be able to add some reviews, but anyone would be able to read them or to see which interviews are incoming. The `Review` database would then be linked to the `Users` one, and one would then truly be sure that the person who wrote a review is the one whose name is indicated above it.

### Addition of filters / sorting features
It could be useful for the judges to see all the reviews of their colleagues criteria by criteria (and not judge by judge as it is now).
I would then add some filters (which would be React states) at the top of the `Reviews.tsx` file, in order to enforce these filters. The display preferences of every judge could even be stored in the `Users` database.

### Dark theme
As it is a bit of a trend on the Internet nowadays, I would add a dark theme to the website. This one would actually be easily implemented as a great part of all the components I used come from Mantine. Then, by adding a context which would store the boolean `dark`, I would just have to use a ternary expression in the `MantineProvider` of `App.tsx` to decide whether everything will be dark or light.

The only difficulty would come from the calendary which is not handled by Mantine. Howerver, it would not be much of a problem as the tiles can be modified in the parameters of the calendar.